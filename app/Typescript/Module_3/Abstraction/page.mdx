# ЁЯФ╖ Abstraction (ржЕрзНржпрж╛ржмрж╕рзНржЯрзНрж░рж╛ржХрж╢ржи)

### ЁЯУЦ рж╕ржВржЬрзНржЮрж╛:

**Abstraction** рж╣рж▓рзЛ ржПржоржи ржПржХржЯрж┐ ржзрж╛рж░ржгрж╛ ржпрзЗржЦрж╛ржирзЗ рж╢рзБржзрзБ ржжрж░ржХрж╛рж░рж┐ ржЕржВрж╢ ржжрзЗржЦрж╛ржирзЛ рж╣рзЯ, ржЕржкрзНрж░рзЯрзЛржЬржирзАрзЯ ржЕржВрж╢ рж▓рзБржХрж╛ржирзЛ рж╣рзЯред ржПржЯрж┐ OOP-ржПрж░ ржПржХржЯрж┐ ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг ржмрзИрж╢рж┐рж╖рзНржЯрзНржп ржпрж╛ ржмрж╛рж╕рзНрждржмрж╛рзЯржиржХрзЗ рж╕рж╣ржЬ ржУ ржкрж░рж┐рж╖рзНржХрж╛рж░ ржХрж░рзЗ рждрзЛрж▓рзЗред

---

### тЬЕ ржХрзЗржи ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж┐?

* ржЗржЙржЬрж╛рж░ржХрзЗ рж╢рзБржзрзБржорж╛рждрзНрж░ ржжрж░ржХрж╛рж░рж┐ ржЕржВрж╢ ржжрзЗржЦрж┐рзЯрзЗ ржЬржЯрж┐рж▓рждрж╛ рж▓рзБржХрж╛ржирзЛрж░ ржЬржирзНржпред
* ржХрзЛржбрзЗрж░ structure ржкрж░рж┐рж╖рзНржХрж╛рж░ ржУ maintainable рж░рж╛ржЦрж╛рж░ ржЬржирзНржпред
* ржПржХрж╛ржзрж┐ржХ ржХрзНрж▓рж╛рж╕рзЗ common behavior ржирж┐рж░рзНржзрж╛рж░ржг ржХрж░рзЗ consistency ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рж╛рж░ ржЬржирзНржпред

---

### тЬи Interface ржжрзНржмрж╛рж░рж╛ Abstraction:

```tsx
interface Vehicle {
  startEngine(): void;
  stopEngine(): void;
  move(): void;
}

class Car implements Vehicle {
  startEngine(): void {
    console.log("Car engine started");
  }
  stopEngine(): void {
    console.log("Car engine stopped");
  }
  move(): void {
    console.log("Car is moving");
  }
}

const myCar = new Car();
myCar.startEngine();
myCar.move();
myCar.stopEngine();
```

ЁЯФН ржПржЦрж╛ржирзЗ `Vehicle` ржЗржирзНржЯрж╛рж░ржлрзЗрж╕ ржЧржаржи ржирж┐рж░рзНржзрж╛рж░ржг ржХрж░рзЗржЫрзЗ, ржХрж┐ржирзНрждрзБ ржмрж╛рж╕рзНрждржм рж░рзВржк `Car` ржХрзНрж▓рж╛рж╕рзЗ ржжрзЗржУрзЯрж╛ рж╣рзЯрзЗржЫрзЗред

---

### тЬи Abstract Class ржжрзНржмрж╛рж░рж╛ Abstraction:

```tsx
abstract class Machine {
  abstract start(): void;
  abstract stop(): void;

  maintenance(): void {
    console.log("Running maintenance...");
  }
}

class Generator extends Machine {
  start(): void {
    console.log("Generator started");
  }
  stop(): void {
    console.log("Generator stopped");
  }
}

const gen = new Generator();
gen.start();
gen.maintenance();
gen.stop();
```

ЁЯФН `Machine` ржХрзНрж▓рж╛рж╕ рж╢рзБржзрзБ рж░рзВржкрж░рзЗржЦрж╛ ржжрзЗрзЯ, ржмрж╛рж╕рзНрждржмрж╛рзЯржи ржХрж░рждрзЗ рж╣рзЯ ржЪрж╛ржЗрж▓рзНржб ржХрзНрж▓рж╛рж╕рзЗред ржкрж╛рж╢рж╛ржкрж╛рж╢рж┐ `maintenance()` ржПрж░ ржорждрзЛ ржХрж┐ржЫрзБ ржХржоржи ржлрж╛ржВрж╢ржиржУ рж╢рзЗрзЯрж╛рж░ ржХрж░рж╛ ржпрж╛рзЯред

---

## ЁЯЖЪ Interface vs Abstract Class:

| ржжрж┐ржХ                  | Interface                             | Abstract Class                   |
| -------------------- | ------------------------------------- | -------------------------------- |
| Instantiate ржХрж░рж╛ ржпрж╛рзЯ? | ржирж╛                                    | ржирж╛                               |
| ржХрзА ржерж╛ржХрзЗ?             | рж╢рзБржзрзБ ржорзЗржержб рж╕рж┐ржЧржирзЗржЪрж╛рж░                    | ржорзЗржержб рж╕рж┐ржЧржирзЗржЪрж╛рж░ + ржХрж┐ржЫрзБ ржмрж╛рж╕рзНрждржм ржорзЗржержб |
| ржХрзАржнрж╛ржмрзЗ implement рж╣рзЯ? | `implements`                          | `extends`                        |
| Multiple use         | Multiple interfaces implement ржХрж░рж╛ ржпрж╛рзЯ | ржПржХржЯрж┐ржЗ extend ржХрж░рж╛ ржпрж╛рзЯ             |

---

## ЁЯУМ ржХржЦржи ржХрзЛржиржЯрж╛ ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржмрзЛ?

* тЬЕ ржХрзЗржмрж▓ structure ржжрж░ржХрж╛рж░ тЖТ **Interface**
* тЬЕ ржХрж┐ржЫрзБ common behavior рж╢рзЗрзЯрж╛рж░ ржХрж░рждрзЗ ржЪрж╛ржЗрж▓рзЗ тЖТ **Abstract Class**
* тЬЕ ржорзЗржержбрзЗрж░ ржнрж┐ржирзНржи ржЖржЪрж░ржг ржжрж░ржХрж╛рж░ тЖТ **Polymorphism**

---

### тЬЕ рж╕ржВржХрзНрж╖рзЗржкрзЗ ржоржирзЗ рж░рж╛ржЦрж╛рж░ ржирж┐ржпрж╝ржо:

> ЁЯОн **Abstraction** = ржжрж░ржХрж╛рж░рж┐ ржЕржВрж╢ ржжрзЗржЦрж╛ржУ, ржмрж╛рж╕рзНрждржмрж╛рзЯржи child ржХрзНрж▓рж╛рж╕рзЗ ржжрж╛ржУред
>
> ЁЯУж Interface structure ржжрзЗрзЯ, abstract class structure + ржХрж┐ржЫрзБ ржХрж╛ржЬржУ ржжрзЗрзЯред
>
> тЬЕ Clean & maintainable architecture-ржПрж░ ржЬржирзНржп abstraction ржЕржкрж░рж┐рж╣рж╛рж░рзНржпред

---
